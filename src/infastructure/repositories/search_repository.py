import logging
from typing import Dict, List
import openai
import qdrant_client
from qdrant_client.models import PointStruct, VectorParams, Distance


# Text data and corresponding metadata
texts = [
    "⌨️ Health metrics AI agent which focuses chat bot only for data entry. Users can enter their quantitative data through text-based prompts.",
    "📞 health metrics AI agent which focuses on voice bot for the data entry. Users can enter their quantitative data through voice-based prompts.",
    "🤖 Health metrics AI agent which focuses chat bot only for data entry. Users can enter their qualitative data through text-based prompts.",
    "📞 health metrics AI agent which focuses on voice bot for the data entry. Users can enter their qualitative data through voice-based prompts.",
    "📃 FHIR tool. An AI agent to convert image into text. Users can upload their image and get FHIR data format. Users can export the data with healthcare coach.",
    "📈 Graphs on the health data. Collections of graphs generated through the healthcare agents on the quantitative data.",
    "🪪 Summary of the health data. A summary of the health data generated by the healthcare agents.",
    "🎉 Recommendation of the health data. A recommendation of the health data generated by the healthcare agents.",
    "📲 Wearable devices. An AI agent to connect wearable devices to the healthcare agents. Users can connect their wearable devices to the healthcare agents.",
    "👨🏼‍⚕️ A general healthcare agent which is focused on answering specialized healthcare topics through chat-based interface.",
    "🥼 A general healthcare agent which is focused on answering specialized healthcare topics through voice-based interface.",
]

metadata = [
    {"screen": "Chat", "intent": True, "chatVariant": "Health metrics agent", "agent_id": "health_metrics", "agent_type": "chat"},
    {"screen": "Voice", "intent": True, "chatVariant": "Voice health metrics agent", "agent_id": "voice_health_metrics", "agent_type": "voice"},
    {"screen": "Chat", "intent": True, "chatVariant": "Voice assessment agent", "agent_id": "assessment", "agent_type": "chat"},
    {"screen": "Voice", "intent": True, "chatVariant": "Voice assessment agent", "agent_id": "voice_assessment", "agent_type": "voice"},
    {"screen": "FHIR file data", "intent": False},
    {"screen": "Data", "intent": False},
    {"screen": "Assessment", "intent": False},
    {"screen": "Recommendations", "intent": False},
    {"screen": "Wearable", "intent": False},
    {"screen": "Chat", "intent": True, "chatVariant": "General Chat agent", "agent_id": "general_chat_response", "agent_type": "chat"},
    {"screen": "Voice", "intent": True, "chatVariant": "General voice agent", "agent_id": "general_voice_response", "agent_type": "voice"},
]

class EmbeddingService:
    def __init__(self, api_key: str, model: str):
        self.openai_client = openai.Client(api_key=api_key)
        self.embedding_model = model
        self.embeddings_cache: Dict[str, List[float]] = {}

    def get_embeddings(self, text: str) -> List[float]:
        if text in self.embeddings_cache:
            return self.embeddings_cache[text]
        else:
            result = self.openai_client.embeddings.create(input=[text], model=self.embedding_model)
            self.embeddings_cache[text] = result.data[0].embedding
            return self.embeddings_cache[text]

class QdrantService:
    def __init__(self):
        self.client = qdrant_client.QdrantClient(":memory:")
        self.collection_name = "example_collection"

    def create_collection(self):
        logging.info("Creating collection...")
        self.client.create_collection(
            self.collection_name,
            vectors_config=VectorParams(
                size=1536,
                distance=Distance.COSINE,
            ),
        )
        logging.info("Collection created.")

    def upsert_points(self, points: List[PointStruct]):
        logging.info("Upserting points...")
        self.client.upsert(self.collection_name, points)
        logging.info("Points upserted.")

    def search(self, query_embedding: List[float], limit: int = 3):
        logging.info("Searching...")
        return self.client.search(
            collection_name=self.collection_name,
            query_vector=query_embedding,
            limit=limit,
        )

class SearchRepository:
    def __init__(self, embedding_service: EmbeddingService, qdrant_service: QdrantService):
        self.embedding_service = embedding_service
        self.qdrant_service = qdrant_service

    def prepare_points(self, texts: List[str], metadata: List[Dict]) -> List[PointStruct]:
        return [
            PointStruct(
                id=idx,
                vector=self.embedding_service.get_embeddings(text),
                payload={"text": text, **meta},
            )
            for idx, (text, meta) in enumerate(zip(texts, metadata))
        ]

    def initialize_qdrant(self):
        points = self.prepare_points(texts, metadata)
        self.qdrant_service.create_collection()
        self.qdrant_service.upsert_points(points)

    def query_text(self, query_text: str):
        try:
            query_embedding = self.embedding_service.get_embeddings(query_text)
            response = self.qdrant_service.search(query_embedding)

            logging.info(f"Query: {query_text}")
            result = []
            for data in response:
                logging.info(f"Text: {data.payload['text']}")
                logging.info(f"Metadata: {data.payload}")
                result.append({
                    "text": data.payload['text'],
                    "metadata": data.payload
                })
            logging.info("*******************************\n\n\n\n")
            return result
        except Exception as e:
            logging.error(f"Failed to search: {e}")
            return []


from config.config import OPEN_AI_API_KEY, EMBEDDING_MODEL
# Initialize services
api_key = OPEN_AI_API_KEY
embedding_model = EMBEDDING_MODEL

embedding_service = EmbeddingService(api_key, embedding_model)
qdrant_service = QdrantService()
search_repository = SearchRepository(embedding_service, qdrant_service)